import streamlit as st
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
import numpy as np

# Configura√ß√£o da p√°gina
st.set_page_config(
    page_title="Dashboard C√¢ncer de Mama - Brasil",
    page_icon="ü©∑",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Carregar dados - CORRIGIDO PARA DADOS POR UF
@st.cache_data
def carregar_dados():
    try:
        # Carregar arquivos do mesmo diret√≥rio
        mortalidade = pd.read_csv("mortalidade_tabela2.csv")
        nunca_mamografia = pd.read_csv("nunca_mamografia_fig15.csv")
        mamografos_uf = pd.read_csv("mamografos_regiao_tabela10_total.csv")
        mamografos_sus = pd.read_csv("mamografos_regiao_tabela11_SUS.csv")
        tempo_laudo = pd.read_csv("tempo_laudo_rastreamento_tabela9.csv")
        
        # DEBUG: Verificar colunas de cada arquivo
        st.write("üîç DEBUG - Colunas dos arquivos:")
        st.write(f"mortalidade: {list(mortalidade.columns)}")
        st.write(f"nunca_mamografia: {list(nunca_mamografia.columns)}")
        st.write(f"mamografos_uf: {list(mamografos_uf.columns)}")
        st.write(f"mamografos_sus: {list(mamografos_sus.columns)}")
        st.write(f"tempo_laudo: {list(tempo_laudo.columns)}")
        
        # Converter porcentagens para num√©rico
        mamografos_uf['Utilizacao_%'] = mamografos_uf['Utiliza√ß√£o(%)'].str.replace('%', '').astype(float)
        
        # CORRE√á√ÉO: Verificar se as colunas de jun√ß√£o existem
        # Primeiro, verificar quais colunas temos em comum
        colunas_mortalidade = set(mortalidade.columns)
        colunas_nunca_mamografia = set(nunca_mamografia.columns)
        colunas_tempo_laudo = set(tempo_laudo.columns)
        
        colunas_comuns = colunas_mortalidade & colunas_nunca_mamografia & colunas_tempo_laudo
        st.write(f"Colunas em comum: {colunas_comuns}")
        
        # Usar 'UF' como chave principal (mais confi√°vel)
        if 'UF' in colunas_mortalidade and 'UF' in colunas_nunca_mamografia and 'UF' in colunas_tempo_laudo:
            # Consolidar dados principais usando UF
            dados = mortalidade.merge(nunca_mamografia, on='UF', how='left')
            dados = dados.merge(tempo_laudo, on='UF', how='left')
        elif 'Regiao' in colunas_mortalidade and 'Regiao' in colunas_nunca_mamografia and 'Regiao' in colunas_tempo_laudo:
            # Tentar com Regiao se UF n√£o estiver dispon√≠vel
            dados = mortalidade.merge(nunca_mamografia, on='Regiao', how='left')
            dados = dados.merge(tempo_laudo, on='Regiao', how='left')
        else:
            st.error("N√£o foi poss√≠vel encontrar colunas comuns para unir os dados")
            return None
        
        # CORRE√á√ÉO: Usar dados espec√≠ficos por UF (n√£o por regi√£o)
        dados = dados.merge(mamografos_uf[['UF', 'Utilizacao_%', 'Mamografos_existentes', 'Mamografos_em_uso']], 
                           on='UF', how='left')
        
        # Adicionar dados do SUS
        dados = dados.merge(mamografos_sus, on='UF', how='left')
        
        st.success("‚úÖ Dados carregados com sucesso!")
        return dados
        
    except Exception as e:
        st.error(f"Erro ao carregar dados: {e}")
        # Mostrar mais detalhes do erro
        import traceback
        st.error(f"Detalhes do erro: {traceback.format_exc()}")
        return None

def calcular_score_criticidade(dados):
    """Calcula score de criticidade para cada estado"""
    dados_score = dados.copy()
    
    # Normalizar cada m√©trica para escala 0-100
    dados_score['Score_Mortalidade'] = (dados_score['Taxa_mortalidade_ajustada'] / dados_score['Taxa_mortalidade_ajustada'].max() * 100).round(1)
    dados_score['Score_Nao_Rastreadas'] = (dados_score['Percentual_nunca_fez_exame'] / dados_score['Percentual_nunca_fez_exame'].max() * 100).round(1)
    dados_score['Score_Laudos_Lentos'] = (dados_score['Mais_60_dias_%'] / dados_score['Mais_60_dias_%'].max() * 100).round(1)
    
    # Score consolidado com pesos
    dados_score['Score_Consolidado'] = (
        dados_score['Score_Mortalidade'] * 0.35 +      # Peso 35%
        dados_score['Score_Nao_Rastreadas'] * 0.35 +   # Peso 35%
        dados_score['Score_Laudos_Lentos'] * 0.30      # Peso 30%
    ).round(1)
    
    # Classificar por criticidade
    dados_score = dados_score.sort_values('Score_Consolidado', ascending=False)
    
    return dados_score

def criar_tabela_criticidade(dados_score, estado_selecionado=None):
    """Cria tabela com ranking de criticidade"""
    
    st.header("üîé Ranking de Criticidade por Estado")
    st.markdown("**Classifica√ß√£o baseada na combina√ß√£o de mortalidade, mulheres n√£o rastreadas e laudos lentos**")
    
    # Criar tabela formatada
    colunas_disponiveis = []
    for coluna in ['UF', 'Regiao', 'Score_Consolidado', 'Taxa_mortalidade_ajustada', 'Percentual_nunca_fez_exame', 'Mais_60_dias_%', 'Obitos']:
        if coluna in dados_score.columns:
            colunas_disponiveis.append(coluna)
    
    tabela_display = dados_score[colunas_disponiveis].copy()
    
    # Renomear colunas
    mapeamento_colunas = {
        'UF': 'UF',
        'Regiao': 'Regi√£o', 
        'Score_Consolidado': 'Score Cr√≠tico',
        'Taxa_mortalidade_ajustada': 'Mortalidade',
        'Percentual_nunca_fez_exame': '% N√£o Rastreadas',
        'Mais_60_dias_%': '% Laudos >60d',
        'Obitos': '√ìbitos'
    }
    
    tabela_display.columns = [mapeamento_colunas.get(col, col) for col in tabela_display.columns]
    
    # Formatar valores
    if 'Mortalidade' in tabela_display.columns:
        tabela_display['Mortalidade'] = tabela_display['Mortalidade'].round(1)
    if '% N√£o Rastreadas' in tabela_display.columns:
        tabela_display['% N√£o Rastreadas'] = tabela_display['% N√£o Rastreadas'].round(1)
    if '% Laudos >60d' in tabela_display.columns:
        tabela_display['% Laudos >60d'] = tabela_display['% Laudos >60d'].round(1)
    
    # Adicionar ranking
    tabela_display.insert(0, 'Posi√ß√£o', range(1, len(tabela_display) + 1))
    
    # Estilizar a tabela
    def color_score(val):
        if val >= 80:
            return 'background-color: #ff4d4d; color: white; font-weight: bold'
        elif val >= 60:
            return 'background-color: #ff9999; color: black; font-weight: bold'
        elif val >= 40:
            return 'background-color: #ffcc99; color: black;'
        elif val >= 20:
            return 'background-color: #ffff99; color: black;'
        else:
            return 'background-color: #ccffcc; color: black;'
    
    def color_estado_selecionado(row):
        if estado_selecionado and row['UF'] == estado_selecionado:
            return ['background-color: #EE82EE; font-weight: bold;'] * len(row)
        else:
            return [''] * len(row)
    
    # Aplicar estilos apenas se a coluna existir
    styled_table = tabela_display.style.apply(color_estado_selecionado, axis=1)
    
    if 'Score Cr√≠tico' in tabela_display.columns:
        styled_table = styled_table.applymap(color_score, subset=['Score Cr√≠tico'])
    
    # Exibir tabela
    st.dataframe(
        styled_table,
        use_container_width=True,
        height=800
    )
    
    # Legenda
    col1, col2, col3, col4, col5 = st.columns(5)
    with col1:
        st.markdown("**üî¥ ‚â•80: Cr√≠tico**")
    with col2:
        st.markdown("**üü† 60-79: Alto**")
    with col3:
        st.markdown("**üü° 40-59: M√©dio**")
    with col4:
        st.markdown("**üü¢ 20-39: Baixo**")
    with col5:
        st.markdown("**üü¢ <20: Muito Baixo**")
    
    return tabela_display

# ... (as outras fun√ß√µes permanecem as mesmas, mas vou manter apenas as essenciais para o exemplo)

def criar_visao_infraestrutura(dados, estado_selecionado):
    """Cria visualiza√ß√£o focada em infraestrutura - CORRIGIDA"""
    st.header("üñ•Ô∏è Infraestrutura de Mam√≥grafos")
    
    estado_data = dados[dados['UF'] == estado_selecionado].iloc[0]
    utilizacao_estado = estado_data['Utilizacao_%']
    mamografos_sus = estado_data['Mamografos_SUS']
    mamografos_existentes = estado_data['Mamografos_existentes']
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric(
            "Utiliza√ß√£o de Mam√≥grafos",
            f"{utilizacao_estado:.1f}%",
            help="% de mam√≥grafos existentes que est√£o em uso"
        )
    
    with col2:
        st.metric(
            "Mam√≥grafos do SUS",
            f"{mamografos_sus:.0f}",
            f"de {mamografos_existentes:.0f} existentes"
        )
    
    with col3:
        if utilizacao_estado > 100:
            status = "‚ùå Dados Inconsistentes"
        elif utilizacao_estado > 80:
            status = "‚úÖ Boa Utiliza√ß√£o"
        elif utilizacao_estado > 60:
            status = "‚ö†Ô∏è Capacidade Ociosa"
        else:
            status = "üî¥ Baixa Utiliza√ß√£o"
        st.metric(
            "Situa√ß√£o",
            status,
            "infraestrutura"
        )
    
    # OBSERVA√á√ÉO ESPEC√çFICA DO ESTADO
    if estado_selecionado == 'PR':
        st.error(f"**Observa√ß√£o - {estado_selecionado}:** ‚ö†Ô∏è DADO INCONSISTENTE: Utiliza√ß√£o de {utilizacao_estado}% (imposs√≠vel), com {estado_data['Mamografos_em_uso']} mam√≥grafos em uso para apenas {mamografos_existentes} existentes, sendo {mamografos_sus} pelo SUS")
    else:
        st.info(f"**Observa√ß√£o - {estado_selecionado}:** Utiliza√ß√£o de {utilizacao_estado}%, com {estado_data['Mamografos_em_uso']} mam√≥grafos em uso, sendo {mamografos_sus} pelo SUS")

def main():
    st.title("üéÄ C√¢ncer de Mama no Brasil üéÄ ")
    st.markdown("### An√°lise Integrada: Mortalidade, Rastreamento e Infraestrutura")
    
    # Carregar dados CORRIGIDOS
    dados = carregar_dados()
    
    if dados is None:
        st.error("N√£o foi poss√≠vel carregar os dados. Verifique se todos os arquivos CSV est√£o no mesmo diret√≥rio:")
        st.markdown("""
        - `mortalidade_tabela2.csv`
        - `nunca_mamografia_fig15.csv` 
        - `mamografos_regiao_tabela10_total.csv`
        - `mamografos_regiao_tabela11_SUS.csv`
        - `tempo_laudo_rastreamento_tabela9.csv`
        """)
        return
    
    # Mostrar preview dos dados carregados
    st.write("üìä Preview dos dados carregados:")
    st.write(dados.head())
    
    # Calcular scores de criticidade
    dados_score = calcular_score_criticidade(dados)
    
    # Sidebar para controles
    with st.sidebar:
        st.header("üéØ Controles")
        
        # Seletor de estado
        estado_selecionado = st.selectbox(
            "Selecione o Estado:",
            options=dados['UF'].unique(),
            index=0
        )
        
        st.markdown("---")
        st.info("""
        **Fontes dos Dados:**
        - ü™¶ Tabela 2: Mortalidade (2022)
        - ü©∫ Figura 15: Rastreamento (PNS 2019)  
        - üñ•Ô∏è Tabela 10: Mam√≥grafos (por UF)
        - üè• Tabela 11: Mam√≥grafos SUS
        - ‚è±Ô∏è Tabela 9: Tempo de laudo
        """)
    
    # Layout principal simplificado para teste
    tab1, tab2 = st.tabs(["üöë Ranking Cr√≠tico", "üñ•Ô∏è Infraestrutura"])
    
    with tab1:
        criar_tabela_criticidade(dados_score, estado_selecionado)
    
    with tab2:
        criar_visao_infraestrutura(dados, estado_selecionado)
    
    # Footer
    st.markdown("---")
    st.markdown("**Fonte**: INCA - Instituto Nacional de C√¢ncer (Dados 2022-2024)")
    st.markdown("**Criado para apoio √† tomada de decis√£o em sa√∫de p√∫blica**")
    st.markdown("*Desenvolvido por Tiago Alves - Cientista de Dados - https://www.linkedin.com/in/tiagoalvesds/*")

if __name__ == "__main__":
    main()